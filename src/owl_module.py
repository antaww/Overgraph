# AUTOGENERATED! DO NOT EDIT! File to edit: owl.ipynb.

# %% auto 0
__all__ = ['map_stats', 'df', 'get_team_profile', 'get_heroes_stat', 'get_players_stat', 'get_heroes_stat_by_player',
           'get_players_stat_by_team', 'get_team_scores']

# %% owl.ipynb 0
import pandas as pd
import streamlit as st
import dateutil.parser as dparser
from streamlit_jupyter import StreamlitPatcher

# %% owl.ipynb 2
import os

project_name = 'Overgraph'
path = os.getcwd().split(project_name)[0] + project_name
owl_path = f'{path}/src/datas/owl'


# %% owl.ipynb 4
map_stats = pd.read_csv(f'{owl_path}/match_map_stats.csv')

# %% owl.ipynb 6
df_2018_s1 = pd.read_csv(f'{owl_path}/phs_2018_stage_1.csv')

# %% owl.ipynb 9
df_2018_s2 = pd.read_csv(f'{owl_path}/phs_2018_stage_2.csv')

# %% owl.ipynb 12
df_2018_s3 = pd.read_csv(f'{owl_path}/phs_2018_stage_3.csv')

# %% owl.ipynb 15
df_2018_s4 = pd.read_csv(f'{owl_path}/phs_2018_stage_4.csv')

# %% owl.ipynb 18
df_2018_po = pd.read_csv(f'{owl_path}/phs_2018_playoffs.csv')

# %% owl.ipynb 21
df_2019_s1 = pd.read_csv(f'{owl_path}/phs_2019_stage_1.csv')

# %% owl.ipynb 24
df_2019_s2 = pd.read_csv(f'{owl_path}/phs_2019_stage_2.csv')

# %% owl.ipynb 27
df_2019_s3 = pd.read_csv(f'{owl_path}/phs_2019_stage_3.csv')

# %% owl.ipynb 30
df_2019_s4 = pd.read_csv(f'{owl_path}/phs_2019_stage_4.csv')

# %% owl.ipynb 33
df_2019_po = pd.read_csv(f'{owl_path}/phs_2019_playoffs.csv')

# %% owl.ipynb 36
df_2020_s1 = pd.read_csv(f'{owl_path}/phs_2020_1.csv')

# %% owl.ipynb 39
df_2020_s2 = pd.read_csv(f'{owl_path}/phs_2020_2.csv')

# %% owl.ipynb 42
df_2021 = pd.read_csv(f'{owl_path}/phs_2021_1.csv')

# %% owl.ipynb 45
df_2022 = pd.read_csv(f'{owl_path}/phs_2022.csv')

# %% owl.ipynb 48
df_2023 = pd.read_csv(f'{owl_path}/phs_2023.csv')

# %% owl.ipynb 51
# merge every dataframes in one
df = pd.concat(
    [df_2018_s1, df_2018_s2, df_2018_s3, df_2018_s4, df_2018_po, df_2019_s1, df_2019_s2, df_2019_s3, df_2019_s4,
     df_2019_po, df_2020_s1, df_2020_s2, df_2021, df_2022, df_2023])

# %% owl.ipynb 54
df.replace({'hero': 'McCree'}, 'Cassidy', inplace=True)
df.replace({'hero': 'Lucio'}, 'Lúcio', inplace=True)
df.replace({'hero': 'Torbjorn'}, 'Torbjörn', inplace=True)
df = df[df['map_type'].str.lower() != 'UNKNOWN'.lower()]
df.replace({'team': 'Paris Eternal'}, 'Vegas Eternal', inplace=True)
df.replace({'team': 'Philadelphia Fusion'}, 'Seoul Infernal', inplace=True)
# todo: rework this part with 'start_time' year extraction and place it in 'stage'
stage_2018 = ['Overwatch League - Stage 1', 'Overwatch League - Stage 2', 'Overwatch League - Stage 3',
              'Overwatch League - Stage 4', 'Overwatch League - Stage 1 - Title Matches',
              'Overwatch League - Stage 2 Title Matches',
              'Overwatch League - Stage 3 Title Matches', 'Overwatch League - Stage 4 Title Matches',
              'Overwatch League Inaugural Season Championship']
stage_2019 = ['Overwatch League Stage 1', 'Overwatch League Stage 2', 'Overwatch League Stage 3',
              'Overwatch League Stage 4', 'Overwatch League Stage 1 Title Matches',
              'Overwatch League Stage 2 Title Matches', 'Overwatch League Stage 3 Title Matches',
              'Overwatch League Stage 4 Title Matches', 'Overwatch League 2019 Post-Season']
stage_2020 = ['OWL 2020 Regular Season', 'OWL APAC All-Stars', 'OWL North America All-Stars']
stage_2021 = ['OWL 2021']
stage_2022 = ['Kickoff Clash: Qualifiers', 'Kickoff Clash: Tournament', 'Midseason Madness: Qualifiers',
              'Midseason Madness: Tournament', 'Summer Showdown: Qualifiers', 'Summer Showdown: Tournament',
              'Countdown Cup: Qualifiers', 'Countdown Cup: Tournament', 'Postseason']
stage_2023 = ['Pro-Am', 'Spring Qualifiers', 'Spring Knockouts', 'Midseason Madness', 'Summer Showdown',
              'Countdown Cup', 'Postseason']

for stage in stage_2018:
    df.replace({'stage': stage}, f'2018 : {stage}', inplace=True)
for stage in stage_2019:
    df.replace({'stage': stage}, f'2019 : {stage}', inplace=True)
for stage in stage_2020:
    df.replace({'stage': stage}, f'2020 : {stage}', inplace=True)
for stage in stage_2021:
    df.replace({'stage': stage}, f'2021 : {stage}', inplace=True)
for stage in stage_2022:
    df.replace({'stage': stage}, f'2022 : {stage}', inplace=True)
for stage in stage_2023:
    df.replace({'stage': stage}, f'2023 : {stage}', inplace=True)



# !!!! to save execution time, match_map_stats.csv cleaned version has been saved
# !!!! if it's your first run, you must uncomment the following part: 
# for col in ['match_winner', 'map_winner', 'map_loser', 'attacker', 'defender', 'team_one_name', 'team_two_name']:
#     map_stats.replace({col: 'Paris Eternal'}, 'Vegas Eternal', inplace=True)
#     map_stats.replace({col: 'Philadelphia Fusion'}, 'Seoul Infernal', inplace=True)
# map_stats['round_start_time'] = map_stats['round_start_time'].str.replace(' UTC', '')
# map_stats['round_end_time'] = map_stats['round_end_time'].str.replace(' UTC', '')
# map_stats['round_start_time'] = map_stats['round_start_time'].apply(lambda x: dparser.parse(x, fuzzy=True))
# map_stats['round_end_time'] = map_stats['round_end_time'].apply(lambda x: dparser.parse(x, fuzzy=True))
# map_stats.to_csv(f'{owl_path}/match_map_stats.csv', index=False)

# %% owl.ipynb 58
def get_team_profile(team: str, stat: str, stage: str = None) -> pd.DataFrame:
    """
    This function generates a profile for a given team, based on a specific statistic and optionally for a specific stage.
    
    Parameters:
    team (str): The name of the team.
    stat (str): The statistic to consider.
    stage (str, optional): The stage to consider. If None, all stages are considered.
    
    Returns:
    pd.DataFrame: A DataFrame containing the team profile.
    """
    
    # Filter the DataFrame based on the team, stat, and hero
    result = df[df['team'] == team]
    result = result[result['stat'] == stat]
    result = result[result['hero'] == 'All Heroes']
    
    # If a stage is specified, filter the DataFrame based on the stage
    if stage:
        print('stage filter')
        result = result[result['stage'] == stage]
    
    # Calculate the total stat amount for each match
    stat_result = result.groupby(['match_id'])['stat_amount'].sum()
    
    # Calculate the total stat amount for each match and start time
    total_stat_amount = result.groupby(['match_id', 'start_time'])['stat_amount'].sum()
    
    # Calculate the number of start times for each match
    number_of_start_time_per_match = total_stat_amount.groupby(['match_id']).count()
    
    # Calculate the average stat amount
    avg_stat = total_stat_amount.groupby(['match_id']).sum() / number_of_start_time_per_match
    
    # Add the total and average stat amounts to the DataFrame
    result['stat_match_total'] = result['match_id'].apply(lambda x: stat_result[x])
    result['avg_stat'] = result['match_id'].apply(lambda x: avg_stat[x])
    
    # Replace the stat amount with the total stat amount
    result['stat_amount'] = result['stat_match_total']
    result = result.drop(columns=['stat_match_total'])
    
    # Merge the DataFrame with the map stats DataFrame
    result = result.reset_index().merge(
        map_stats[['match_id', 'match_winner', 'team_one_name', 'team_two_name']], on='match_id')
    
    # Add the opponent team to the DataFrame
    result['opponent'] = result['team_one_name']
    result['opponent'] = result['opponent'].where(result['team_one_name'] != team, result['team_two_name'])
    result = result.drop(columns=['team_one_name', 'team_two_name'])
    
    # Remove duplicate matches
    result = result.drop_duplicates(subset='match_id')
    result = result.set_index('match_id')
    
    # Convert the start time to a datetime object and sort the DataFrame by start time
    result['start_time'] = result['start_time'].str.replace(' UTC', '')
    result['start_time'] = result['start_time'].apply(lambda x: dparser.parse(x, fuzzy=True))
    result = result.sort_values(by='start_time')
    
    # Calculate the win rate for each match
    result['winrate'] = 0
    win = 0
    loss = 0
    for match in result.index:
        if result.loc[match, 'match_winner'] == team:
            win += 1
        else:
            loss += 1
        result.loc[match, 'winrate'] = win / (win + loss) * 100
    
    # Remove unnecessary columns
    result = result.drop(columns=['index', 'stat', 'map_type', 'map', 'player', 'hero', 'team'])
    
    # Rename the columns
    result.rename(
        columns={'start_time': 'Start Time', 'stat_amount': stat, 'match_winner': 'Match Winner', 'winrate': 'Winrate', 'opponent': 'Opponent', 'stage': 'Stage', 'avg_stat': f'Avg {stat}'},
        inplace=True)
    
    result.index.name = 'Match ID'
    
    return result

# %% owl.ipynb 60
def get_heroes_stat(stat: str) -> pd.DataFrame:
    """
    This function calculates the total amount of a specific statistic for each hero in the dataset.

    Parameters:
    stat (str): The statistic to consider.

    Returns:
    pd.DataFrame: A DataFrame containing the total amount of the statistic for each hero, sorted in descending order.
    """
    # Filter the DataFrame based on the statistic
    result = df[df['stat'] == stat]
    
    # Group by hero and sum the statistic amounts
    result = result.groupby('hero')['stat_amount'].sum().sort_values(ascending=False)
    
    # Set the name of the Series and its index
    result.name = stat
    result.index.name = 'Hero'
    
    # Convert the Series to a DataFrame
    result = result.to_frame()
    
    return result


# %% owl.ipynb 62
def get_players_stat(stat: str) -> pd.DataFrame:
    """
    This function calculates the total amount of a specific statistic for each player in the dataset.

    Parameters:
    stat (str): The statistic to consider.

    Returns:
    pd.DataFrame: A DataFrame containing the total amount of the statistic for each player, sorted in descending order.
    """
    # Filter the DataFrame based on the statistic
    result = df[df['stat'] == stat]

    # Group by player and sum the statistic amounts
    result = result.groupby('player')['stat_amount'].sum().sort_values(ascending=False)

    # Set the name of the Series and its index
    result.name = stat
    result.index.name = 'Player'

    # Convert the Series to a DataFrame
    result = result.to_frame()

    return result

# %% owl.ipynb 64
def avg_stats_per_game(stat: str, player: str) -> pd.DataFrame:
    """
    This function calculates the average amount of a specific statistic per game for a specific player.

    Parameters:
    stat (str): The statistic to consider.
    player (str): The player to consider.

    Returns:
    pd.DataFrame: A DataFrame containing the average amount of the statistic per game for each hero the player has played, 
    the number of games played with each hero, sorted in descending order of the average statistic.
    """
    # Filter the DataFrame based on the statistic and player
    player_data = df[(df['stat'] == stat) & (df['player'] == player)]
    results = pd.DataFrame(columns=['Hero', 'Stat', 'Avg per game'])

    # Filter the DataFrame based on the statistic
    stat_data = player_data[player_data['stat'] == stat]
    
    # Calculate the average statistic amount per game for each hero
    avg_per_game = stat_data.groupby(['hero'])['stat_amount'].mean().reset_index()
    avg_per_game.columns = ['Hero', 'Avg per game']
    
    # Calculate the number of games played with each hero
    avg_per_game['Number of game'] = stat_data.groupby(['hero'])['stat_amount'].count().reset_index()['stat_amount']
    
    # Concatenate the results
    results = pd.concat([results, avg_per_game], ignore_index=True, sort=False)

    return results[['Hero', 'Avg per game', 'Number of game']]

# %% owl.ipynb 65
def get_heroes_stat_by_player(stat: str, player: str) -> pd.Series:
    """
    This function calculates the total amount of a specific statistic for each hero played by a specific player.

    Parameters:
    stat (str): The statistic to consider.
    player (str): The player to consider.

    Returns:
    pd.Series: A Series containing the total amount of the statistic for each hero played by the player, 
    sorted in descending order, and the average statistic per game.
    """
    # Filter the DataFrame based on the statistic and player
    result = df[(df['stat'] == stat) & (df['player'] == player)].groupby('hero')['stat_amount'].sum().sort_values(
        ascending=False)
    result.name = stat
    result.index.name = 'Hero'
    
    # Calculate the average statistic per game
    stat_avg = avg_stats_per_game(stat, player)
    
    # Merge the total and average statistics
    result = result.reset_index().merge(stat_avg, on='Hero', how='left')
    
    # Reset the index
    result = result.set_index('Hero')
    
    return result

# %% owl.ipynb 68
def get_players_stat_by_team(stat: str, team: str) -> pd.DataFrame:
    """
    This function calculates the total amount of a specific statistic for each player in a specific team.

    Parameters:
    stat (str): The statistic to consider.
    team (str): The team to consider.

    Returns:
    pd.DataFrame: A DataFrame containing the total amount of the statistic for each player in the team, sorted in descending order.
    """
    # Filter the DataFrame based on the statistic and team
    result = df[(df['stat'] == stat) & (df['team'] == team)].groupby('player')['stat_amount'].sum().sort_values(
        ascending=False)

    # Set the name of the Series and its index
    result.name = stat
    result.index.name = 'Player'
    result = result.to_frame()

    return result

# %% owl.ipynb 70
def get_team_scores(team: str, map_type: str = None, map_name: str = None) -> pd.DataFrame:
    """
    This function generates a DataFrame containing the scores of a specific team, optionally filtered by map type and map name.

    Parameters:
    team (str): The name of the team.
    map_type (str, optional): The type of the map. If None, all map types are considered.
    map_name (str, optional): The name of the map. If None, all maps are considered.

    Returns:
    pd.DataFrame: A DataFrame containing the scores of the team, including the number of wins, losses, and the win rate.
    """
    # Stock every unique game from team (each game as a unique 'match_id'), team name is stocked in 'team_one_name' or 'team_two_name'
    team_games = map_stats[(map_stats['team_one_name'] == team) | (map_stats['team_two_name'] == team)]
    if map_type:  # only 1 row per game
        # Add column 'map_type' from dataframe 'df'
        team_games = team_games.merge(df[['match_id', 'map_type']], on='match_id')
        team_games = team_games[team_games['map_type'].str.lower() == map_type.lower()]
        if map_name:  # only 1 row per game
            team_games = team_games[team_games['map_name'].str.lower() == map_name.lower()]
        # Get one row per map
        team_games = team_games.drop_duplicates(subset='round_start_time')
        # Do not keep twice same game_number per match_id
        df_grp = team_games.groupby(['match_id', 'game_number'])
        team_games = df_grp.first().reset_index()
    else:  # only 1 row per match
        # Get one row per match
        team_games = team_games.drop_duplicates(subset='match_id')

    # Get teams list
    opponents = team_games[['team_one_name', 'team_two_name']]
    # Remove team input from opponents list
    opponents = opponents[opponents != team]
    # Regroup in one column and remove duplicates
    opponents = opponents.stack().reset_index(drop=True).drop_duplicates()

    results = pd.DataFrame(columns=['team', 'opponent', 'win', 'loss', 'winrate', 'map_type', 'only_matches'])

    for opponent in opponents:
        matches = team_games[((team_games['team_one_name'] == team) &
                              (team_games['team_two_name'] == opponent)) | (
                                 (team_games['team_one_name'] == opponent) & (team_games['team_two_name'] == team))]

        if map_type:
            wins = matches['map_winner'] == team
        else:
            wins = matches['match_winner'] == team

        total_matches = matches.shape[0]
        if total_matches == 0:
            continue
        wins = wins.sum()
        losses = len(matches) - wins
        winrate = wins / total_matches

        row = pd.DataFrame(
            {'team': team, 'opponent': opponent, 'total_matches': total_matches, 'win': wins, 'loss': losses,
             'winrate': winrate * 100, 'map_type': map_type,
             'only_matches': not map_type, 'map_name': map_name}, index=[0])
        results = pd.concat([results, row])

    # Rename columns
    results.rename(columns={'team': 'Team', 'opponent': 'Opponent', 'total_matches': 'Total Matches', 'win': 'Win',
                            'loss': 'Loss', 'winrate': 'Winrate', 'map_type': 'Map Type',
                            'only_matches': 'Only Matches', 'map_name': 'Map Name'},
                   inplace=True)

    # Reorder columns
    results = results[['Team', 'Opponent', 'Total Matches', 'Win', 'Loss', 'Winrate', 'Map Type', 'Map Name', 'Only Matches']]
    if not map_type:
        results = results.drop(columns='Map Type')
    if not map_name:
        results = results.drop(columns='Map Name')

    results = results.set_index('Team')
    return results
