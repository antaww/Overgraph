# AUTOGENERATED! DO NOT EDIT! File to edit: owl.ipynb.

# %% auto 0
__all__ = ['map_stats', 'df', 'get_team_profile', 'get_heroes_stat', 'get_players_stat', 'get_heroes_stat_by_player',
           'get_players_stat_by_team', 'get_team_scores']

# %% owl.ipynb 0
import dateutil.parser as dparser
import pandas as pd
from streamlit_jupyter import StreamlitPatcher

# %% owl.ipynb 2
import os

project_name = 'Overgraph'
path = os.getcwd().split(project_name)[0] + project_name
owl_path = f'{path}/src/datas/owl'


# %% owl.ipynb 4
map_stats = pd.read_csv(f'{owl_path}/match_map_stats.csv')

# %% owl.ipynb 6
df_2018_s1 = pd.read_csv(f'{owl_path}/phs_2018_stage_1.csv')

# %% owl.ipynb 9
df_2018_s2 = pd.read_csv(f'{owl_path}/phs_2018_stage_2.csv')

# %% owl.ipynb 12
df_2018_s3 = pd.read_csv(f'{owl_path}/phs_2018_stage_3.csv')

# %% owl.ipynb 15
df_2018_s4 = pd.read_csv(f'{owl_path}/phs_2018_stage_4.csv')

# %% owl.ipynb 18
df_2018_po = pd.read_csv(f'{owl_path}/phs_2018_playoffs.csv')

# %% owl.ipynb 21
df_2019_s1 = pd.read_csv(f'{owl_path}/phs_2019_stage_1.csv')

# %% owl.ipynb 24
df_2019_s2 = pd.read_csv(f'{owl_path}/phs_2019_stage_2.csv')

# %% owl.ipynb 27
df_2019_s3 = pd.read_csv(f'{owl_path}/phs_2019_stage_3.csv')

# %% owl.ipynb 30
df_2019_s4 = pd.read_csv(f'{owl_path}/phs_2019_stage_4.csv')

# %% owl.ipynb 33
df_2019_po = pd.read_csv(f'{owl_path}/phs_2019_playoffs.csv')

# %% owl.ipynb 36
df_2020_s1 = pd.read_csv(f'{owl_path}/phs_2020_1.csv')

# %% owl.ipynb 39
df_2020_s2 = pd.read_csv(f'{owl_path}/phs_2020_2.csv')

# %% owl.ipynb 42
df_2021 = pd.read_csv(f'{owl_path}/phs_2021_1.csv')

# %% owl.ipynb 45
df_2022 = pd.read_csv(f'{owl_path}/phs_2022.csv')

# %% owl.ipynb 48
df_2023 = pd.read_csv(f'{owl_path}/phs_2023.csv')

# %% owl.ipynb 51
# merge every dataframes in one
df = pd.concat(
    [df_2018_s1, df_2018_s2, df_2018_s3, df_2018_s4, df_2018_po, df_2019_s1, df_2019_s2, df_2019_s3, df_2019_s4,
     df_2019_po, df_2020_s1, df_2020_s2, df_2021, df_2022, df_2023])

# %% owl.ipynb 54
df.replace({'hero': 'McCree'}, 'Cassidy', inplace=True)
df.replace({'hero': 'Lucio'}, 'Lúcio', inplace=True)
df.replace({'hero': 'Torbjorn'}, 'Torbjörn', inplace=True)
df = df[df['map_type'].str.lower() != 'UNKNOWN'.lower()]
df.replace({'team': 'Paris Eternal'}, 'Vegas Eternal', inplace=True)
df.replace({'team': 'Philadelphia Fusion'}, 'Seoul Infernal', inplace=True)

# !!!! to save execution time, match_map_stats.csv cleaned version has been saved
# !!!! if it's your first run, you must uncomment the following part: 
# for col in ['match_winner', 'map_winner', 'map_loser', 'attacker', 'defender', 'team_one_name', 'team_two_name']:
#     map_stats.replace({col: 'Paris Eternal'}, 'Vegas Eternal', inplace=True)
#     map_stats.replace({col: 'Philadelphia Fusion'}, 'Seoul Infernal', inplace=True)
# map_stats['round_start_time'] = map_stats['round_start_time'].str.replace(' UTC', '')
# map_stats['round_end_time'] = map_stats['round_end_time'].str.replace(' UTC', '')
# map_stats['round_start_time'] = map_stats['round_start_time'].apply(lambda x: dparser.parse(x, fuzzy=True))
# map_stats['round_end_time'] = map_stats['round_end_time'].apply(lambda x: dparser.parse(x, fuzzy=True))
# map_stats.to_csv(f'{owl_path}/match_map_stats.csv', index=False)

# %% owl.ipynb 58
def get_team_profile(team: str, stat: str, stage: str = None) -> pd.DataFrame:
    result = df[df['team'] == team]
    result = result[result['stat'] == stat]
    result = result[result['hero'] == 'All Heroes']
    if stage:
        print('stage filter')
        result = result[result['stage'] == stage]
    # sum of every stat_amount for the same match_id
    stat_result = result.groupby(['match_id'])['stat_amount'].sum()
    # before calculating the avg_stat, sum the stat_amount for the same match_id and same start_time
    # example:  3 differents start_time & 1 match_id, the mean will be the sum of the 3 stat_amount divided by 3
    total_stat_amount = result.groupby(['match_id', 'start_time'])['stat_amount'].sum()
    # get the number of start_time for the same match_id
    number_of_start_time_per_match = total_stat_amount.groupby(['match_id']).count()
    # calculate the avg_stat
    avg_stat = total_stat_amount.groupby(['match_id']).sum() / number_of_start_time_per_match
    result['stat_match_total'] = result['match_id'].apply(lambda x: stat_result[x])
    result['avg_stat'] = result['match_id'].apply(lambda x: avg_stat[x])
    # drop duplicates
    # make every value of stat_match_total in stat_amount
    result['stat_amount'] = result['stat_match_total']
    result = result.drop(columns=['stat_match_total'])
    #     result = result.groupby(['match_id'])['stat_amount'].sum()
    # else:
    #     # result = result.groupby(['match_id', 'start_time'])['stat_amount'].sum()
    #     result = result.groupby(['match_id'])['stat_amount'].sum()
    result = result.reset_index().merge(
        map_stats[['match_id', 'match_winner', 'team_one_name', 'team_two_name']], on='match_id')
    result['opponent'] = result['team_one_name']
    result['opponent'] = result['opponent'].where(result['team_one_name'] != team, result['team_two_name'])
    result = result.drop(columns=['team_one_name', 'team_two_name'])
    result = result.drop_duplicates(subset='match_id')
    # 
    # # result = result.drop_duplicates(subset='start_time')
    # # add a column avg stat, that is the average of the stat for the same match_id
    # result['avg_stat'] = result.groupby('match_id')['stat_amount'].transform('mean')
    # # result = result.drop_duplicates(subset='match_id')
    result = result.set_index('match_id')
    result['start_time'] = result['start_time'].str.replace(' UTC', '')
    result['start_time'] = result['start_time'].apply(lambda x: dparser.parse(x, fuzzy=True))
    result = result.sort_values(by='start_time')
    # 
    # # add a column winrate, that will start from 0%, and will be updated 
    result['winrate'] = 0
    win = 0
    loss = 0
    for match in result.index:
        if result.loc[match, 'match_winner'] == team:
            win += 1
        else:
            loss += 1
        result.loc[match, 'winrate'] = win / (win + loss) * 100
        
    # delete useless columns
    result = result.drop(columns=['index', 'stat', 'map_type', 'map', 'player', 'hero', 'team'])

    result.rename(
        columns={'start_time': 'Start Time', 'stat_amount': stat, 'match_winner': 'Match Winner', 'winrate': 'Winrate', 'opponent': 'Opponent', 'stage': 'Stage', 'avg_stat': f'Avg {stat}'},
        inplace=True)
    result.index.name = 'Match ID'
    return result

# %% owl.ipynb 60
def get_heroes_stat(stat: str) -> pd.Series:
    result = df[df['stat'] == stat].groupby('hero')['stat_amount'].sum().sort_values(ascending=False)
    result.name = stat
    result.index.name = 'Hero'
    return result


# %% owl.ipynb 62
def get_players_stat(stat: str) -> pd.Series:
    result = df[df['stat'] == stat].groupby('player')['stat_amount'].sum().sort_values(ascending=False)
    result.name = stat
    result.index.name = 'Player'
    return result

# %% owl.ipynb 64
def avg_stats_per_game(stat: str, player: str) -> pd.DataFrame:
    player_data = df[(df['stat'] == stat) & (df['player'] == player)]
    results = pd.DataFrame(columns=['Hero', 'Stat', 'Avg per game'])

    stat_data = player_data[player_data['stat'] == stat]
    avg_per_game = stat_data.groupby(['hero'])['stat_amount'].mean().reset_index()
    avg_per_game.columns = ['Hero', 'Avg per game']
    avg_per_game['Number of game'] = stat_data.groupby(['hero'])['stat_amount'].count().reset_index()['stat_amount']
    results = pd.concat([results, avg_per_game], ignore_index=True, sort=False)

    return results[['Hero', 'Avg per game', 'Number of game']]

# %% owl.ipynb 65
def get_heroes_stat_by_player(stat: str, player: str) -> pd.Series:
    result = df[(df['stat'] == stat) & (df['player'] == player)].groupby('hero')['stat_amount'].sum().sort_values(
        ascending=False)
    result.name = stat
    result.index.name = 'Hero'
    stat_avg = avg_stats_per_game(stat, player)
    result = result.reset_index().merge(stat_avg, on='Hero', how='left')
    #reset index
    result = result.set_index('Hero')
    return result

# %% owl.ipynb 68
def get_players_stat_by_team(stat: str, team: str) -> pd.DataFrame:
    result = df[(df['stat'] == stat) & (df['team'] == team)].groupby('player')['stat_amount'].sum().sort_values(
        ascending=False)
    result.name = stat
    result.index.name = 'Player'
    return result

# %% owl.ipynb 70
def get_team_scores(team: str, map_type: str = None) -> pd.DataFrame:
    # stock every unique game from team (each game as a unique 'match_id'), team name is stocked in 'team_one_name' or 'team_two_name'
    team_games = map_stats[(map_stats['team_one_name'] == team) | (map_stats['team_two_name'] == team)]
    if map_type:  # only 1 row per game
        # add column 'map_type' from dataframe 'df'
        team_games = team_games.merge(df[['match_id', 'map_type']], on='match_id')
        print(team_games['map_type'].str.lower().unique())
        team_games = team_games[team_games['map_type'].str.lower() == map_type.lower()]
        # get one row per map
        team_games = team_games.drop_duplicates(subset='round_start_time')
        # do not keep twice same game_number per match_id
        df_grp = team_games.groupby(['match_id', 'game_number'])
        team_games = df_grp.first().reset_index()
    else:  # only 1 row per match
        # get one row per match
        team_games = team_games.drop_duplicates(subset='match_id')

    # get teams list
    opponents = team_games[['team_one_name', 'team_two_name']]
    # remove team input from opponents list
    opponents = opponents[opponents != team]
    # regroup in one column and remove duplicates
    opponents = opponents.stack().reset_index(drop=True).drop_duplicates()

    results = pd.DataFrame(columns=['team', 'opponent', 'win', 'loss', 'winrate', 'map_type', 'only_matches'])

    for opponent in opponents:
        matches = team_games[((team_games['team_one_name'] == team) &
                              (team_games['team_two_name'] == opponent)) | (
                                     (team_games['team_one_name'] == opponent) & (team_games['team_two_name'] == team))]

        if map_type:
            wins = matches['map_winner'] == team
        else:
            wins = matches['match_winner'] == team

        total_matches = matches.shape[0]
        if total_matches == 0:
            continue
        wins = wins.sum()
        losses = len(matches) - wins
        winrate = wins / total_matches

        row = pd.DataFrame(
            {'team': team, 'opponent': opponent, 'total_matches': total_matches, 'win': wins, 'loss': losses,
             'winrate': winrate * 100, 'map_type': map_type,
             'only_matches': not map_type}, index=[0])
        results = pd.concat([results, row])

    # rename columns
    results.rename(columns={'team': 'Team', 'opponent': 'Opponent', 'total_matches': 'Total Matches', 'win': 'Win',
                            'loss': 'Loss', 'winrate': 'Winrate', 'map_type': 'Map Type',
                            'only_matches': 'Only Matches'},
                   inplace=True)

    # reorder columns
    results = results[['Team', 'Opponent', 'Total Matches', 'Win', 'Loss', 'Winrate', 'Map Type', 'Only Matches']]
    if not map_type:
        results = results.drop(columns='Map Type')

    results = results.set_index('Team')
    return results
