# AUTOGENERATED! DO NOT EDIT! File to edit: owl.ipynb.

# %% auto 0
__all__ = ['map_stats', 'df', 'get_heroes_stat', 'get_heroes_stat_by_player', 'get_players_stat_by_team', 'get_team_scores']

# %% owl.ipynb 0
import pandas as pd
import streamlit as st

from streamlit_jupyter import StreamlitPatcher

# %% owl.ipynb 2
import os

project_name = 'Overgraph'
path = os.getcwd().split(project_name)[0] + project_name
owl_path = f'{path}/src/datas/owl'

# %% owl.ipynb 4
map_stats = pd.read_csv(f'{owl_path}/match_map_stats.csv')

# %% owl.ipynb 6
df_2018_s1 = pd.read_csv(f'{owl_path}/phs_2018_stage_1.csv')

# %% owl.ipynb 9
df_2018_s2 = pd.read_csv(f'{owl_path}/phs_2018_stage_2.csv')

# %% owl.ipynb 12
df_2018_s3 = pd.read_csv(f'{owl_path}/phs_2018_stage_3.csv')

# %% owl.ipynb 15
df_2018_s4 = pd.read_csv(f'{owl_path}/phs_2018_stage_4.csv')

# %% owl.ipynb 18
df_2018_po = pd.read_csv(f'{owl_path}/phs_2018_playoffs.csv')

# %% owl.ipynb 21
df_2019_s1 = pd.read_csv(f'{owl_path}/phs_2019_stage_1.csv')

# %% owl.ipynb 24
df_2019_s2 = pd.read_csv(f'{owl_path}/phs_2019_stage_2.csv')

# %% owl.ipynb 27
df_2019_s3 = pd.read_csv(f'{owl_path}/phs_2019_stage_3.csv')

# %% owl.ipynb 30
df_2019_s4 = pd.read_csv(f'{owl_path}/phs_2019_stage_4.csv')

# %% owl.ipynb 33
df_2019_po = pd.read_csv(f'{owl_path}/phs_2019_playoffs.csv')

# %% owl.ipynb 36
df_2020_s1 = pd.read_csv(f'{owl_path}/phs_2020_1.csv')

# %% owl.ipynb 39
df_2020_s2 = pd.read_csv(f'{owl_path}/phs_2020_2.csv')

# %% owl.ipynb 42
df_2021 = pd.read_csv(f'{owl_path}/phs_2021_1.csv')

# %% owl.ipynb 45
df_2022 = pd.read_csv(f'{owl_path}/phs_2022.csv')

# %% owl.ipynb 48
df_2023 = pd.read_csv(f'{owl_path}/phs_2023.csv')

# %% owl.ipynb 51
# merge every dataframes in one
df = pd.concat(
    [df_2018_s1, df_2018_s2, df_2018_s3, df_2018_s4, df_2018_po, df_2019_s1, df_2019_s2, df_2019_s3, df_2019_s4,
     df_2019_po, df_2020_s1, df_2020_s2, df_2021, df_2022, df_2023])

# %% owl.ipynb 54
# replace every 'McCree' in 'hero' column by 'Cassidy' (do not create a new column)
df.replace({'hero': 'McCree'}, 'Cassidy', inplace=True)
df.replace({'hero': 'Lucio'}, 'Lúcio', inplace=True)
df.replace({'hero': 'Torbjorn'}, 'Torbjörn', inplace=True)
df = df[df['team'].str.lower() != df['player'].str.lower()]
# todo rename every 'old' teams by their 'new' name

# %% owl.ipynb 59
def get_heroes_stat(stat: str) -> pd.Series:
    result = df[df['stat'] == stat].groupby('hero')['stat_amount'].sum().sort_values(ascending=False)
    result.name = stat
    result.index.name = 'Hero'
    return result


# %% owl.ipynb 61
def get_heroes_stat_by_player(stat: str, player: str) -> pd.Series:
    result = df[(df['stat'] == stat) & (df['player'] == player)].groupby('hero')['stat_amount'].sum().sort_values(
        ascending=False)
    result.name = stat
    result.index.name = 'Hero'
    return result

# %% owl.ipynb 64
def get_players_stat_by_team(stat: str, team: str) -> pd.DataFrame:
    result = df[(df['stat'] == stat) & (df['team'] == team)].groupby('player')['stat_amount'].sum().sort_values(
        ascending=False)
    result.name = stat
    result.index.name = 'Player'
    return result

# %% owl.ipynb 66
def get_team_scores(team: str, map_type: str = None) -> pd.DataFrame:
    # stock every unique game from team (each game as a unique 'match_id'), team name is stocked in 'team_one_name' or 'team_two_name'
    team_games = map_stats[(map_stats['team_one_name'] == team) | (map_stats['team_two_name'] == team)]
    if map_type:  # only 1 row per game
        # add column 'map_type' from dataframe 'df'
        team_games = team_games.merge(df[['match_id', 'map_type']], on='match_id')
        print(team_games['map_type'].str.lower().unique())
        team_games = team_games[team_games['map_type'].str.lower() == map_type.lower()]
        # get one row per map
        team_games = team_games.drop_duplicates(subset='round_start_time')
        # do not keep twice same game_number per match_id
        df_grp = team_games.groupby(['match_id', 'game_number'])
        team_games = df_grp.first().reset_index()
    else:  # only 1 row per match
        # get one row per match
        team_games = team_games.drop_duplicates(subset='match_id')

    # get teams list
    opponents = team_games[['team_one_name', 'team_two_name']]
    # remove team input from opponents list
    opponents = opponents[opponents != team]
    # regroup in one column and remove duplicates
    opponents = opponents.stack().reset_index(drop=True).drop_duplicates()

    results = pd.DataFrame(columns=['team', 'opponent', 'win', 'loss', 'winrate', 'map_type', 'only_matches'])

    for opponent in opponents:
        matches = team_games[((team_games['team_one_name'] == team) &
                              (team_games['team_two_name'] == opponent)) | (
                                     (team_games['team_one_name'] == opponent) & (team_games['team_two_name'] == team))]

        if map_type:
            wins = matches['map_winner'] == team
        else:
            wins = matches['match_winner'] == team

        total_matches = matches.shape[0]
        if total_matches == 0:
            continue
        wins = wins.sum()
        losses = len(matches) - wins
        winrate = wins / total_matches

        row = pd.DataFrame(
            {'team': team, 'opponent': opponent, 'total_matches': total_matches, 'win': wins, 'loss': losses,
             'winrate': winrate, 'map_type': map_type,
             'only_matches': not map_type}, index=[0])
        results = pd.concat([results, row])

    # rename columns
    results.rename(columns={'team': 'Team', 'opponent': 'Opponent', 'total_matches': 'Total Matches', 'win': 'Win',
                            'loss': 'Loss', 'winrate': 'Winrate', 'map_type': 'Map Type', 'only_matches': 'Only Matches'},
                   inplace=True)

    # reorder columns
    results = results[['Team', 'Opponent', 'Total Matches', 'Win', 'Loss', 'Winrate', 'Map Type', 'Only Matches']]
    if not map_type:
        results = results.drop(columns='Map Type')

    results = results.reset_index(drop=True)
    return results
