# AUTOGENERATED! DO NOT EDIT! File to edit: owl.ipynb.

# %% auto 0
__all__ = ['map_stats', 'df', 'get_team_profile', 'get_heroes_stat', 'get_players_stat', 'get_heroes_stat_by_player',
           'get_players_stat_by_team', 'get_team_scores']

# %% owl.ipynb 2
import os

import dateutil.parser as dparser
# %% owl.ipynb 0
import pandas as pd

project_name = 'Overgraph'
path = os.getcwd().split(project_name)[0] + project_name
owl_path = f'{path}/src/datas/owl'

# %% owl.ipynb 4
map_stats = pd.read_csv(f'{owl_path}/match_map_stats.csv')

# %% owl.ipynb 6
df_2018_s1 = pd.read_csv(f'{owl_path}/phs_2018_stage_1.csv')

# %% owl.ipynb 9
df_2018_s2 = pd.read_csv(f'{owl_path}/phs_2018_stage_2.csv')

# %% owl.ipynb 12
df_2018_s3 = pd.read_csv(f'{owl_path}/phs_2018_stage_3.csv')

# %% owl.ipynb 15
df_2018_s4 = pd.read_csv(f'{owl_path}/phs_2018_stage_4.csv')

# %% owl.ipynb 18
df_2018_po = pd.read_csv(f'{owl_path}/phs_2018_playoffs.csv')

# %% owl.ipynb 21
df_2019_s1 = pd.read_csv(f'{owl_path}/phs_2019_stage_1.csv')

# %% owl.ipynb 24
df_2019_s2 = pd.read_csv(f'{owl_path}/phs_2019_stage_2.csv')

# %% owl.ipynb 27
df_2019_s3 = pd.read_csv(f'{owl_path}/phs_2019_stage_3.csv')

# %% owl.ipynb 30
df_2019_s4 = pd.read_csv(f'{owl_path}/phs_2019_stage_4.csv')

# %% owl.ipynb 33
df_2019_po = pd.read_csv(f'{owl_path}/phs_2019_playoffs.csv')

# %% owl.ipynb 36
df_2020_s1 = pd.read_csv(f'{owl_path}/phs_2020_1.csv')

# %% owl.ipynb 39
df_2020_s2 = pd.read_csv(f'{owl_path}/phs_2020_2.csv')

# %% owl.ipynb 42
df_2021 = pd.read_csv(f'{owl_path}/phs_2021_1.csv')

# %% owl.ipynb 45
df_2022 = pd.read_csv(f'{owl_path}/phs_2022.csv')

# %% owl.ipynb 48
df_2023 = pd.read_csv(f'{owl_path}/phs_2023.csv')

# %% owl.ipynb 51
# merge every dataframes in one
df = pd.concat(
    [df_2018_s1, df_2018_s2, df_2018_s3, df_2018_s4, df_2018_po, df_2019_s1, df_2019_s2, df_2019_s3, df_2019_s4,
     df_2019_po, df_2020_s1, df_2020_s2, df_2021, df_2022, df_2023])

# %% owl.ipynb 54
df.replace({'hero': 'McCree'}, 'Cassidy', inplace=True)
df.replace({'hero': 'Lucio'}, 'Lúcio', inplace=True)
df.replace({'hero': 'Torbjorn'}, 'Torbjörn', inplace=True)
df = df[df['map_type'].str.lower() != 'UNKNOWN'.lower()]
df.replace({'team': 'Paris Eternal'}, 'Vegas Eternal', inplace=True)
df.replace({'team': 'Philadelphia Fusion'}, 'Seoul Infernal', inplace=True)
# todo: rework this part with 'start_time' year extraction and place it in 'stage'
stage_2018 = ['Overwatch League - Stage 1', 'Overwatch League - Stage 2', 'Overwatch League - Stage 3',
              'Overwatch League - Stage 4', 'Overwatch League - Stage 1 - Title Matches',
              'Overwatch League - Stage 2 Title Matches',
              'Overwatch League - Stage 3 Title Matches', 'Overwatch League - Stage 4 Title Matches',
              'Overwatch League Inaugural Season Championship']
stage_2019 = ['Overwatch League Stage 1', 'Overwatch League Stage 2', 'Overwatch League Stage 3',
              'Overwatch League Stage 4', 'Overwatch League Stage 1 Title Matches',
              'Overwatch League Stage 2 Title Matches', 'Overwatch League Stage 3 Title Matches',
              'Overwatch League Stage 4 Title Matches', 'Overwatch League 2019 Post-Season']
stage_2020 = ['OWL 2020 Regular Season', 'OWL APAC All-Stars', 'OWL North America All-Stars']
stage_2021 = ['OWL 2021']
stage_2022 = ['Kickoff Clash: Qualifiers', 'Kickoff Clash: Tournament', 'Midseason Madness: Qualifiers',
              'Midseason Madness: Tournament', 'Summer Showdown: Qualifiers', 'Summer Showdown: Tournament',
              'Countdown Cup: Qualifiers', 'Countdown Cup: Tournament', 'Postseason']
stage_2023 = ['Pro-Am', 'Spring Qualifiers', 'Spring Knockouts', 'Midseason Madness', 'Summer Showdown',
              'Countdown Cup', 'Postseason']

for stage in stage_2018:
    df.replace({'stage': stage}, f'2018 : {stage}', inplace=True)
for stage in stage_2019:
    df.replace({'stage': stage}, f'2019 : {stage}', inplace=True)
for stage in stage_2020:
    df.replace({'stage': stage}, f'2020 : {stage}', inplace=True)
for stage in stage_2021:
    df.replace({'stage': stage}, f'2021 : {stage}', inplace=True)
for stage in stage_2022:
    df.replace({'stage': stage}, f'2022 : {stage}', inplace=True)
for stage in stage_2023:
    df.replace({'stage': stage}, f'2023 : {stage}', inplace=True)


# !!!! to save execution time, match_map_stats.csv cleaned version has been saved
# !!!! if it's your first run, you must uncomment the following part: 
# for col in ['match_winner', 'map_winner', 'map_loser', 'attacker', 'defender', 'team_one_name', 'team_two_name']:
#     map_stats.replace({col: 'Paris Eternal'}, 'Vegas Eternal', inplace=True)
#     map_stats.replace({col: 'Philadelphia Fusion'}, 'Seoul Infernal', inplace=True)
# map_stats['round_start_time'] = map_stats['round_start_time'].str.replace(' UTC', '')
# map_stats['round_end_time'] = map_stats['round_end_time'].str.replace(' UTC', '')
# map_stats['round_start_time'] = map_stats['round_start_time'].apply(lambda x: dparser.parse(x, fuzzy=True))
# map_stats['round_end_time'] = map_stats['round_end_time'].apply(lambda x: dparser.parse(x, fuzzy=True))
# map_stats.to_csv(f'{owl_path}/match_map_stats.csv', index=False)

# %% owl.ipynb 58
def get_team_profile(team: str, stat: str, stage: str = None) -> pd.DataFrame:
    """
    This function generates a profile for a given team, based on a specific statistic and optionally for a specific stage.
    
    Parameters:
    team (str): The name of the team.
    stat (str): The statistic to consider.
    stage (str, optional): The stage to consider. If None, all stages are considered.
    
    Returns:
    pd.DataFrame: A DataFrame containing the team profile.
    """

    # Filter the DataFrame based on the team, stat, and hero
    result = df[df['team'] == team]
    result = result[result['stat'] == stat]
    result = result[result['hero'] == 'All Heroes']

    # If a stage is specified, filter the DataFrame based on the stage
    if stage:
        print('stage filter')
        result = result[result['stage'] == stage]

    # Calculate the total stat amount for each match
    stat_result = result.groupby(['match_id'])['stat_amount'].sum()

    # Calculate the total stat amount for each match and start time
    total_stat_amount = result.groupby(['match_id', 'start_time'])['stat_amount'].sum()

    # Calculate the number of start times for each match
    number_of_start_time_per_match = total_stat_amount.groupby(['match_id']).count()

    # Calculate the average stat amount
    avg_stat = total_stat_amount.groupby(['match_id']).sum() / number_of_start_time_per_match

    # Add the total and average stat amounts to the DataFrame
    result['stat_match_total'] = result['match_id'].apply(lambda x: stat_result[x])
    result['avg_stat'] = result['match_id'].apply(lambda x: avg_stat[x])

    # Replace the stat amount with the total stat amount
    result['stat_amount'] = result['stat_match_total']
    result = result.drop(columns=['stat_match_total'])

    # Merge the DataFrame with the map stats DataFrame
    result = result.reset_index().merge(
        map_stats[['match_id', 'match_winner', 'team_one_name', 'team_two_name']], on='match_id')

    # Add the opponent team to the DataFrame
    result['opponent'] = result['team_one_name']
    result['opponent'] = result['opponent'].where(result['team_one_name'] != team, result['team_two_name'])
    result = result.drop(columns=['team_one_name', 'team_two_name'])

    # Remove duplicate matches
    result = result.drop_duplicates(subset='match_id')
    result = result.set_index('match_id')

    # Convert the start time to a datetime object and sort the DataFrame by start time
    result['start_time'] = result['start_time'].str.replace(' UTC', '')
    result['start_time'] = result['start_time'].apply(lambda x: dparser.parse(x, fuzzy=True))
    result = result.sort_values(by='start_time')

    # Calculate the win rate for each match
    result['winrate'] = 0
    win = 0
    loss = 0
    for match in result.index:
        if result.loc[match, 'match_winner'] == team:
            win += 1
        else:
            loss += 1
        result.loc[match, 'winrate'] = win / (win + loss) * 100

    # Remove unnecessary columns
    result = result.drop(columns=['index', 'stat', 'map_type', 'map', 'player', 'hero', 'team'])

    # Rename the columns
    result.rename(
        columns={'start_time': 'Start Time', 'stat_amount': stat, 'match_winner': 'Match Winner', 'winrate': 'Winrate',
                 'opponent': 'Opponent', 'stage': 'Stage', 'avg_stat': f'Avg {stat}'},
        inplace=True)

    result.index.name = 'Match ID'

    return result


# %% owl.ipynb 60
def get_heroes_stat(stat: str) -> pd.Series:
    result = df[df['stat'] == stat].groupby('hero')['stat_amount'].sum().sort_values(ascending=False)
    result.name = stat
    result.index.name = 'Hero'
    return result


# %% owl.ipynb 62
def get_players_stat(stat: str) -> pd.Series:
    result = df[df['stat'] == stat].groupby('player')['stat_amount'].sum().sort_values(ascending=False)
    result.name = stat
    result.index.name = 'Player'
    return result


# %% owl.ipynb 64
def avg_stats_per_game(stat: str, player: str) -> pd.DataFrame:
    player_data = df[(df['stat'] == stat) & (df['player'] == player)]
    results = pd.DataFrame(columns=['Hero', 'Stat', 'Avg per game'])

    stat_data = player_data[player_data['stat'] == stat]
    avg_per_game = stat_data.groupby(['hero'])['stat_amount'].mean().reset_index()
    avg_per_game.columns = ['Hero', 'Avg per game']
    avg_per_game['Number of game'] = stat_data.groupby(['hero'])['stat_amount'].count().reset_index()['stat_amount']
    results = pd.concat([results, avg_per_game], ignore_index=True, sort=False)

    return results[['Hero', 'Avg per game', 'Number of game']]


# %% owl.ipynb 65
def get_heroes_stat_by_player(stat: str, player: str) -> pd.Series:
    result = df[(df['stat'] == stat) & (df['player'] == player)].groupby('hero')['stat_amount'].sum().sort_values(
        ascending=False)
    result.name = stat
    result.index.name = 'Hero'
    stat_avg = avg_stats_per_game(stat, player)
    result = result.reset_index().merge(stat_avg, on='Hero', how='left')
    # reset index
    result = result.set_index('Hero')
    return result


# %% owl.ipynb 68
def get_players_stat_by_team(stat: str, team: str) -> pd.DataFrame:
    result = df[(df['stat'] == stat) & (df['team'] == team)].groupby('player')['stat_amount'].sum().sort_values(
        ascending=False)
    result.name = stat
    result.index.name = 'Player'
    return result


# %% owl.ipynb 70
def get_team_scores(team: str, map_type: str = None) -> pd.DataFrame:
    # stock every unique game from team (each game as a unique 'match_id'), team name is stocked in 'team_one_name' or 'team_two_name'
    team_games = map_stats[(map_stats['team_one_name'] == team) | (map_stats['team_two_name'] == team)]
    if map_type:  # only 1 row per game
        # add column 'map_type' from dataframe 'df'
        team_games = team_games.merge(df[['match_id', 'map_type']], on='match_id')
        print(team_games['map_type'].str.lower().unique())
        team_games = team_games[team_games['map_type'].str.lower() == map_type.lower()]
        # get one row per map
        team_games = team_games.drop_duplicates(subset='round_start_time')
        # do not keep twice same game_number per match_id
        df_grp = team_games.groupby(['match_id', 'game_number'])
        team_games = df_grp.first().reset_index()
    else:  # only 1 row per match
        # get one row per match
        team_games = team_games.drop_duplicates(subset='match_id')

    # get teams list
    opponents = team_games[['team_one_name', 'team_two_name']]
    # remove team input from opponents list
    opponents = opponents[opponents != team]
    # regroup in one column and remove duplicates
    opponents = opponents.stack().reset_index(drop=True).drop_duplicates()

    results = pd.DataFrame(columns=['team', 'opponent', 'win', 'loss', 'winrate', 'map_type', 'only_matches'])

    for opponent in opponents:
        matches = team_games[((team_games['team_one_name'] == team) &
                              (team_games['team_two_name'] == opponent)) | (
                                     (team_games['team_one_name'] == opponent) & (team_games['team_two_name'] == team))]

        if map_type:
            wins = matches['map_winner'] == team
        else:
            wins = matches['match_winner'] == team

        total_matches = matches.shape[0]
        if total_matches == 0:
            continue
        wins = wins.sum()
        losses = len(matches) - wins
        winrate = wins / total_matches

        row = pd.DataFrame(
            {'team': team, 'opponent': opponent, 'total_matches': total_matches, 'win': wins, 'loss': losses,
             'winrate': winrate * 100, 'map_type': map_type,
             'only_matches': not map_type}, index=[0])
        results = pd.concat([results, row])

    # rename columns
    results.rename(columns={'team': 'Team', 'opponent': 'Opponent', 'total_matches': 'Total Matches', 'win': 'Win',
                            'loss': 'Loss', 'winrate': 'Winrate', 'map_type': 'Map Type',
                            'only_matches': 'Only Matches'},
                   inplace=True)

    # reorder columns
    results = results[['Team', 'Opponent', 'Total Matches', 'Win', 'Loss', 'Winrate', 'Map Type', 'Only Matches']]
    if not map_type:
        results = results.drop(columns='Map Type')

    results = results.set_index('Team')
    return results
